---
output: html_document
editor_options: 
  chunk_output_type: console
---

# R Modulo 4.2 - Estrutura do habitat {#estrhab}

### RESUMO {-}



### Apresentação {-}



## Sobre os dados

Usaremos para esse tutorial dois conjuntos de dados. A **Matriz ambiental** ([ppbio06p-amb.xlsx](https://docs.google.com/spreadsheets/d/1V_QxcorksaSOa40Uzj1z2jy02WgKeFTx/edit?usp=drive_link&ouid=101766125969589673518&rtpof=true&sd=true)) de dados coletados no Programa de Pesquisa em Biodiversidade - PPBio (Veja [Programa de Pesquisa em Biodiversidade -- PPBio](https://ppbio.inpa.gov.br/Sobre)). Esses são dados de **variáveis ambientais** distribuidas em diversas unidades amostrais (UA's ou sítios). Essa é a **matriz bruta de dados**, porque os valores ainda não foram transformados [@RN67]. Note que as variáveis foram medidas em diferentes unidades (cm, m, °C, mg/L, etc.), com uma alta amplitude de variação, sugerido uso de matriz transformada e/ou reescalada.
Além disso usaremos a **tabela de agrupamentos** ([ppbio06-grupos](https://docs.google.com/spreadsheets/d/1H52eBBxZ1k-6Xgrse87etq6mq3mMUTZi/edit?usp=drive_link&ouid=101766125969589673518&rtpof=true&sd=true)).

**Revise as informações sobre as bases de dados no Capítulo \@ref(bases). As dases de dados para esse Módulo podem ser baixadam na Seção \@ref(arqs).**

## Organização básica

```{r, eval=FALSE}
dev.off() #apaga os graficos, se houver algum
rm(list=ls(all=TRUE)) #limpa a memória
cat("\014") #limpa o console 
```

### Instalando os pacotes necessários para esse módulo.

Se você ja fez o módulo anterior, não vai precisar instalar nenhum pacote novo. Os pacotes necessários serão carregados ao longo desse módulo.

```{r, eval=FALSE}
install.packages("psych")
install.packages("corrplot")
```

Agora vamos **definir o diretório de trabalho**. Esse código é usado para obter e definir o diretório de trabalho atual no R. O comando `getwd()` retorna o caminho do diretório onde o R está lendo e salvando arquivos. O comando `setwd()` muda esse diretório de trabalho para o caminho especificado entre aspas. No seu caso, você deve ajustar o caminho para o seu próprio diretório de trabalho. **Lembre de usar a barra "/" entre os diretórios. E não a contra-barra "\\".**

```{r, eval=FALSE}
getwd()
setwd("C:/Seu/Diretório/De/Trabalho")
```

## Importando a planilha

Note que o símbolo [`#`]{style="color:green"} em programação R significa que o texto que vem depois dele é um comentário e não será executado pelo programa. Isso é útil para explicar o código ou deixar anotações.  
	- Ajuste a primeira linha do código abaixo para refletir ["C:/Seu/Diretório/De/Trabalho/Planilha.xlsx"]{style="color:blue"}.  
	- Ajuste o parâmetro `sheet = "Sheet1"` para refletir a aba correta do arquivo .xlsx a ser importado. Vamos trabalhar com os dados do ano 1.

```{r, results='hold'}
#dir <- getwd() #criamos um vetor com o diretório  de trbalho 
#shell.exec(dir) #abre o diretorio de trabalho no Windows Explorer
library(openxlsx)
ppbio <- read.xlsx("D:/Elvio/OneDrive/Disciplinas/_EcoNumerica/5.Matrizes/ppbio06p-amb.xlsx",
                   rowNames = T, colNames = T,
                   sheet = "ano1")
str(ppbio)
#View(ppbio)
ppbio[1:5,1:5] #[1:5,1:5] mostra apenas as linhas e colunas de 1 a 5.
```

Exibindo os dados importados (esses comando são "case-sensitive" `ignore.case(object)`).

```{r, eval=FALSE, results='hold'}
#View(ppbio)
print(ppbio[1:8,1:8])
ppbio[1:10,1:10]
str(ppbio)
mode(ppbio)
class(ppbio)
```

## Reset point

```{r, eval=TRUE}
m_amb <- ppbio
#pat <- "^S"
#m_amb <- m_amb[!grepl(pat, rownames(m_amb)), ] #exclui quem começa com pat
```
Aqui cria-se um novo objeto do R (`m_trab`, ou a matriz de trabalho, para esse momento) que substitui a matriz de dados original, por uma nova matriz que pode ser a matriz relativizada, transformada, transposta, etc. Dessa forma, mantemos a matriz de dados original caso precisemos dela novamente (Veja a Tabela \@ref(tab:200arqs)).

**Revise Seção \@ref(abrev) e a Tabela de Abreviações (\@ref(tab:200m_2)) na mesma Seção que resumem os tipos de matrizes e suas abreviações, para os nossos códigos.**

## Correlograma e remoção de variáveis redundantes ou desnecessárias

```{r, eval=TRUE, results='hold', fig.show='hold'}
library(psych)
colnames(m_amb)
pairs.panels(m_amb[,1:10],
             method = "pearson", # correlation method
             scale = FALSE, lm = FALSE,
             hist.col = "#00AFBB", pch = 19,
             density = TRUE,  # show density plots
             ellipses = TRUE, # show correlation ellipses
             alpha = 0.5)

cor <- cor(m_amb)
cor
library(corrplot)
corrplot(cor, method = "circle")
#win.print()
#corrplot(cor, method = "circle")
#dev.off()
```

## Deletando variáveis colineares

Primeiro vamos listar as variáveis com correlação maior que 70% ou r > 0.7.

```{r, eval=TRUE, results='hold'} 
# Get upper triangle (to avoid duplicate pairs)
r <- 0.7
cor_pairs <- which(abs(cor) > r & abs(cor) < 1, arr.ind = TRUE)

# Extract unique variable pairs
results <- data.frame(
  var1 = rownames(cor)[cor_pairs[, 1]],
  var2 = colnames(cor)[cor_pairs[, 2]],
  correlation = cor[cor_pairs]
)

# Remove duplicates (e.g. A-B and B-A)
results <- results[results$var1 < results$var2, ]

# Sort by absolute correlation (descending)
results <- results[order(-abs(results$correlation)), ]
results
```

Agora que temos as variáveis correlacionadas, prosseguimos para deleta-las.

```{r, eval=TRUE, results='hold'}
colnames(m_amb)
del_cols <- c("m.distsource", "m.elev") #exemplo, "g.river_length","g.altitude"
m_amb_part <- m_amb[, !(colnames(m_amb) %in% del_cols)]
```

## Somando variáveis redundantes

Algumas dessa variáveis são redundantes, vamos soma-las. 

```{r, eval=TRUE, results='hold'}

m_amb_part$s.gravel <- m_amb_part$s.smlgrav + m_amb_part$s.lrggrav + m_amb_part$s.cobbles
m_amb_part <- m_amb_part[, !(colnames(m_amb_part)
                             %in% c("s.smlgrav", "s.lrggrav", "s.cobbles"))]
m_amb_part$s.rock <- m_amb_part$s.rocks + m_amb_part$s.bedrock
m_amb_part <- m_amb_part[, !(colnames(m_amb_part)
                             %in% c("s.rocks", "s.bedrock"))]
m_amb_part$h.algae <- m_amb_part$h.filalgae + m_amb_part$h.attalgae
m_amb_part <- m_amb_part[, !(colnames(m_amb_part)
                             %in% c("h.filalgae", "h.attalgae"))]
m_amb_part$h.debris <- m_amb_part$h.smldeb + m_amb_part$h.lrgdeb
m_amb_part <- m_amb_part[, !(colnames(m_amb_part)
                             %in% c("h.smldeb", "h.lrgdeb"))]

colnames(m_amb_part)
m_amb_part
```

Salvando a matriz final particionada de dados ambientais.

```{r, eval=TRUE}
write.table(m_amb_part, "m_amb_part.csv",
            sep = ";", dec = ".", #"\t",
            row.names = TRUE,
            quote = TRUE,
            append = FALSE)
m_amb_part <- read.csv("m_amb_part.csv",
                  sep = ";", dec = ".",
                  row.names = 1,
                  header = TRUE,
                  na.strings = NA)
```

## Tabela de dados ambientais

Nessa etapa precisaremos da tabela de grupos. Selecionamos a aba `ambientalp`, porque nela constam os agrupamentos *a-priori* para os dados ambientais.

```{r, results='hold'}
library(openxlsx)
t_grps <- read.xlsx("D:/Elvio/OneDrive/Disciplinas/_EcoNumerica/5.Matrizes/ppbio06-grupos.xlsx",
                   rowNames = T, colNames = T,
                   sheet = "ambientalp")
str(t_grps)
#View(ppbio)
t_grps[1:4,1:4] #[1:4,1:4] mostra apenas as linhas e colunas de 1 a 4.
```

```{r, eval=TRUE, results='hold'}
library(dplyr)
library(tidyr)
m_trab <- m_amb_part %>%
  rename_with(~ gsub("_", ".", .)) #apenas troquei o underscore pelo ponto. 

m <- m_trab %>%
  group_by(Area = t_grps$area,
           Habitat = t_grps$ambiente,
           Ponto = t_grps$UA) %>%
  summarise(across(where(is.numeric),
                   list(mean = mean, min = min, max = max)),
            .groups = 'drop') %>%
  pivot_longer(
    cols = -c(Area, Habitat, Ponto),
    names_to = c("Variable", ".value"),
    names_sep = "_"
  )

m <- as.data.frame(m)
m_wide <- m %>%
  mutate(stat_string = ifelse(Variable == c("fq.w.vel"),
                              paste0(round(mean, 3), "(", round(min, 3), "-", round(max, 3), ")"),
                              paste0(round(mean, 1), "(", round(min, 1), "-", round(max, 1), ")"))) %>%
  unite("Location", Area, Habitat, Ponto, sep = "_") %>%
  select(Variable, Location, stat_string) %>%
  pivot_wider(names_from = Location, values_from = stat_string)

m_wide
m_wide <- as.data.frame(m_wide)
m_wide

#Exportando dados para Excel----
library(openxlsx)
write.xlsx(m_wide, file = "tabela de habitat.xlsx", rowNames = FALSE)
wb <- loadWorkbook("tabela de habitat.xlsx")
writeData(wb, sheet = "Sheet 1", x = m_wide)
saveWorkbook(wb, "tabela de habitat.xlsx", overwrite = TRUE)

#Escolher sumário de uma variavel----
m
var <- "h.roots"
m[m$Variable == var, "mean"] #cada valor de var
summary(m[m$Variable == var, "mean"]) #sumário dos valores de var

#Escolher sumário de um grupo de variáveis do df m----
vars <- unique(grep("^h\\.", m$Variable, value = TRUE))
summaries <- list() #criam uma lista vazia para guardar os sumários
# Loop para cada variável do grupo e guarda em summaries
for (var in vars) {
  summaries[[var]] <- summary(m[m$Variable == var, "mean"])
}
# var is a temporary variable used in the for loop to iterate through
# each variable name that starts with "h."

summaries
summary_table <- do.call(rbind, lapply(summaries, as.data.frame.list))
round(summary_table, 2)
#sink(file = "summary_h.txt", split = TRUE)
round(summary_table[order(summary_table$Mean, decreasing = FALSE), ], 2)
#sink()

#Tabela limpa
summary_table <- cbind(Variable = rownames(summary_table), summary_table)
rownames(summary_table) <- NULL
colnames(summary_table) <- c("Variable", "Min", "Q1", "Median", "Mean", "Q3", "Max")
summary_table
```

## Apêndices {.unnumbered}

## Sites consultados {.unnumbered}

## Script limpo {-}

Aqui apresento o scrip na íntegra sem os textos ou outros comentários. Você pode copiar e colar no R para executa-lo. Lembre de remover os [`#`]{style=color:green} ou [`##`]{style=color:green} caso necessite executar essas linhas.

```{r, eval=FALSE, echo=FALSE, purl=FALSE}
knitr::purl(input = "2-04-2-rmd5_amb.Rmd", output = "script-rmd5.txt", documentation = 0)
Script <- readLines("script-rmd5.txt")
Script <- Script[Script != ""]
writeLines(Script, "script-rmd5.txt")
cat(Script, sep = "\n")
```

```{r, eval=FALSE, echo=TRUE, purl=FALSE}

```

## Referências {-}
